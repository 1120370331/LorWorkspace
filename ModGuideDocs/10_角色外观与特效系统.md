# 角色外观与特效系统

本文档详细介绍如何为核心书页制作角色外观（皮肤），以及如何创建和使用自定义战斗特效。

## 目录

- [一、角色皮肤概述](#一角色皮肤概述)
- [二、皮肤资源放置方式](#二皮肤资源放置方式)
- [三、ModInfo.xml配置详解](#三modinfoxml配置详解)
- [四、攻击特效位置配置](#四攻击特效位置配置)
- [五、动作音效绑定](#五动作音效绑定)
- [六、特效系统底层原理](#六特效系统底层原理)
- [七、自定义特效类（C#方式）](#七自定义特效类c方式)
- [八、使用原版特效](#八使用原版特效)
- [九、AssetBundle特效制作](#九assetbundle特效制作)
- [十、纯代码特效](#十纯代码特效)
- [十一、程序化特效（闪光/离子/激光）](#十一程序化特效闪光离子激光)
- [十二、资源总结](#十二资源总结)

---

## 一、角色皮肤概述

角色皮肤是核心书页在战斗中显示的立绘/动画。

### 在EquipPage中关联皮肤

```xml
<Book ID="10000001">
    <CharacterSkin>my_character_skin</CharacterSkin>
    <CharacterSkinType>Custom</CharacterSkinType>
    <RandomFace>true</RandomFace>  <!-- 可选：随机面部表情 -->
</Book>
```

| 标签 | 说明 |
|------|------|
| `CharacterSkin` | 皮肤名称，对应 `Resource/CharacterSkin/` 下的文件夹名 |
| `CharacterSkinType` | 散图模式设为 `Custom`，AssetBundle模式设为 `Lor` |
| `RandomFace` | 可选，启用随机面部表情 |

---

## 二、皮肤资源放置方式

### 方式A: AssetBundle（推荐用于复杂动画）

```
Resource/AssetBundle/[皮肤名称]
```

- Unity AssetBundle文件（无扩展名）
- 需要用Unity打包角色的Sprite动画
- 寒昼事务所等大型mod使用此方式
- 文件大小通常在1-15MB
- EquipPage中设置 `CharacterSkinType="Lor"`

### 方式B: 散图模式（推荐用于静态立绘）

```
Resource/CharacterSkin/[皮肤名称]/
├── ModInfo.Xml          # 皮肤配置文件（必须）
├── Thumb.png            # 缩略图（可选）
└── ClothCustom/         # 动作图片文件夹（必须）
    ├── Default.png      # 默认站姿（必须）
    ├── Guard.png        # 防御
    ├── Evade.png        # 回避
    ├── Damaged.png      # 受伤
    ├── Slash.png        # 斩击
    ├── Slash2.png       # 斩击2（可选）
    ├── Penetrate.png    # 穿刺
    ├── Penetrate2.png   # 穿刺2（可选）
    ├── Hit.png          # 打击
    ├── Hit2.png         # 打击2（可选）
    ├── Move.png         # 移动（可选）
    ├── Fire.png         # 远程攻击（可选）
    ├── Aim.png          # 瞄准（可选）
    ├── Special.png      # 特殊动作（可选）
    └── S1.png ~ S15.png # 额外特殊动作（可选）
```

**重要**：EquipPage中必须设置 `CharacterSkinType="Custom"`

### 动作图片规格

| 属性 | 推荐值 |
|------|--------|
| 格式 | PNG（带透明通道） |
| 尺寸 | 512x512 或 1024x1024 |
| 色彩模式 | RGBA |

### 角色大小调整（重要）

**关键原理**：游戏会将图片拉伸到固定大小显示，因此：
- 直接缩小图片分辨率（如512→256）只会让图像变模糊，不会改变角色显示大小
- 要调整角色大小，需要改变人物在画布中的占比

**正确做法**：在固定尺寸画布（如512x512）中，通过增加透明边距来控制角色大小。

**参考数据**（来自实际mod分析）：
- 画布尺寸：512x512
- 站姿内容：约200x250像素，占画布约40%
- 攻击动作：约300-400像素宽，占画布60-80%
- 人物底部距画布底部：约100-150像素

**Python处理脚本示例**：
```python
from PIL import Image

# 将原图缩小后放到512x512画布中央
img = Image.open('原图.png').convert('RGBA')
content_size = (200, 200)  # 目标内容大小
img_small = img.resize(content_size, Image.LANCZOS)

# 创建透明画布
canvas = Image.new('RGBA', (512, 512), (0, 0, 0, 0))

# 放置位置（居中，底部留100像素）
x = (512 - content_size[0]) // 2
y = 512 - content_size[1] - 100
canvas.paste(img_small, (x, y), img_small)
canvas.save('输出.png')
```

### 绿幕抠图（推荐）

使用绿幕背景的原图比AI抠图（如rembg）更准确：

```python
from PIL import Image

def remove_green(img):
    """去除绿幕背景"""
    img = img.convert('RGBA')
    pixels = img.load()
    w, h = img.size
    for y in range(h):
        for x in range(w):
            r, g, b, a = pixels[x, y]
            # 绿色明显高于红蓝时视为背景
            if g > 100 and g > r * 1.3 and g > b * 1.3:
                pixels[x, y] = (0, 0, 0, 0)
    return img
```

### 版图切割注意事项

从多动作版图切割时，人物可能跨越格子边界：

```python
# 每个格子可能需要不同的边界调整
# [left_expand, right_shrink] 正数=扩展/收缩像素数
ADJUSTMENTS = {
    'Default': [0, 30],      # 右边收缩30px，避免切到相邻动作
    'Slash': [40, 80],       # 左边扩展40px，右边收缩80px
    'Hit': [40, 10],
    'Penetrate': [50, 0],    # 左边扩展50px
}
```

### 动作复用

如果缺少某些动作图，可以复用其他动作：

```python
import shutil
# 用Hit动作填充其他动作
shutil.copy('Hit.png', 'Hit2.png')
shutil.copy('Hit.png', 'Slash2.png')
shutil.copy('Hit.png', 'Penetrate2.png')
shutil.copy('Hit.png', 'Fire.png')  # 远程攻击
```

### 方向翻转

如果角色朝向反了，批量翻转所有图片：

```python
from PIL import Image
import os

for f in os.listdir('.'):
    if f.endswith('.png'):
        img = Image.open(f)
        img = img.transpose(Image.FLIP_LEFT_RIGHT)
        img.save(f)
```

---

## 三、ModInfo.xml配置详解

散图模式必须包含 `ModInfo.Xml` 配置文件（注意文件名大小写）：

### 基础配置（推荐）

```xml
<ModInfo>
  <ClothInfo>
    <Name>角色名</Name>
    <Default>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Default>
    <Guard>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Guard>
    <Evade>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Evade>
    <Damaged>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Damaged>
    <Slash>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Slash>
    <Penetrate>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Penetrate>
    <Hit>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Hit>
    <Move>
      <Direction>Front</Direction>
      <Pivot pivot_x="0" pivot_y="-200" />
      <Head head_x="0" head_y="0" rotation="0" head_enable="False" />
    </Move>
  </ClothInfo>
</ModInfo>
```

### 关键参数说明

| 参数 | 说明 |
|------|------|
| `pivot_x` | 锚点水平位置，正值锚点向左（图像向右显示），负值锚点向右（图像向左显示） |
| `pivot_y` | 锚点垂直位置，负值越大锚点越高（图像越往上显示） |
| `Direction` | `Front`（正面）或 `Side`（侧面） |
| `head_enable` | 是否启用独立头部动画 |

**理解pivot（锚点）**：pivot是图像的定位点，游戏会将锚点对齐到角色站位。因此：
- 锚点向左移动 → 图像整体向右显示
- 锚点向上移动 → 图像整体向下显示

### 调整技巧

- `pivot_y` 值越小（负数越大），角色显示位置越高
- 每个动作可以有不同的 pivot 值，用于微调不同姿势的位置
- 建议先用统一的 pivot 值测试，再根据需要微调各动作

---

## 四、攻击特效位置配置

在 `<ClothInfo>` 中添加 `<AtkEffectPivotInfo>` 来配置攻击特效的生成位置：

```xml
<AtkEffectPivotInfo>
  <!-- 特效根节点 -->
  <atkEffectRoot>
    <localPosition x="0" y="1.94" z="0"/>
    <localScale x="1" y="1" z="1"/>
    <localEulerAngles x="0" y="0" z="0"/>
  </atkEffectRoot>

  <!-- 打击特效位置 -->
  <atkEffectPivot_H>
    <localPosition x="0.8" y="2.85" z="0"/>
    <localScale x="1" y="1" z="1"/>
    <localEulerAngles x="0" y="0" z="0"/>
  </atkEffectPivot_H>

  <!-- 斩击特效位置 -->
  <atkEffectPivot_J>
    <localPosition x="-1.4" y="-0.6" z="0"/>
    <localScale x="1" y="1" z="1"/>
    <localEulerAngles x="0" y="0" z="8"/>
  </atkEffectPivot_J>

  <!-- 穿刺特效位置 -->
  <atkEffectPivot_Z>
    <localPosition x="-6.4" y="0.85" z="0"/>
    <localScale x="1" y="1" z="1"/>
    <localEulerAngles x="0" y="0" z="0"/>
  </atkEffectPivot_Z>

  <!-- 防御/回避/特殊/远程 -->
  <atkEffectPivot_G>...</atkEffectPivot_G>
  <atkEffectPivot_E>...</atkEffectPivot_E>
  <atkEffectPivot_S>...</atkEffectPivot_S>
  <atkEffectPivot_F>...</atkEffectPivot_F>
</AtkEffectPivotInfo>
```

### 锚点类型对照表

| 节点 | 对应动作 |
|------|----------|
| `atkEffectPivot_H` | 打击 (Hit) |
| `atkEffectPivot_J` | 斩击 (Slash) |
| `atkEffectPivot_Z` | 穿刺 (Penetrate) |
| `atkEffectPivot_G` | 防御 (Guard) |
| `atkEffectPivot_E` | 回避 (Evade) |
| `atkEffectPivot_S` | 特殊动作 (Special) |
| `atkEffectPivot_F` | 远程攻击 (Fire) |

### 特殊动作特效位置

```xml
<SpecialMotionPivotInfo>
  <Evade>
    <localPosition x="0.7" y="1.8" z="0"/>
    <localScale x="1" y="1" z="1"/>
    <localEulerAngles x="0" y="0" z="0"/>
  </Evade>
  <S1>...</S1>
  <S2>...</S2>
  <!-- S3 ~ S15 -->
</SpecialMotionPivotInfo>
```

---

## 五、动作音效绑定

在 `<ClothInfo>` 中添加 `<SoundList>` 来绑定动作音效：

```xml
<SoundList>
  <!-- Motion: 动作类型, WinExternal: 是否使用外部文件, Win: 音效文件名 -->
  <SoundInfo Motion="H" WinExternal="true" Win="Hit.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="H2" WinExternal="true" Win="Hit.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="J" WinExternal="true" Win="Slash.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="J2" WinExternal="true" Win="Slash.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="Z" WinExternal="true" Win="Penetrate.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="Z2" WinExternal="true" Win="Penetrate.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="G" WinExternal="true" Win="Guard.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="E" WinExternal="true" Win="Evasion.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="F" WinExternal="true" Win="Gun.wav" LoseExternal="false" Lose=""/>
  <SoundInfo Motion="S1" WinExternal="true" Win="S1.wav" LoseExternal="false" Lose=""/>
  <!-- S2 ~ S15 -->
</SoundList>
```

### 音效文件放置位置

```
Char/[皮肤名称]/MotionSound/
├── Hit.wav
├── Slash.wav
├── Penetrate.wav
├── Guard.wav
├── Evasion.wav
├── Gun.wav
└── S1.wav ~ S15.wav
```

### Motion类型对照表

| Motion | 对应动作 |
|--------|----------|
| H / H2 | 打击 |
| J / J2 | 斩击 |
| Z / Z2 | 穿刺 |
| G | 防御 |
| E | 回避 |
| F | 远程攻击 |
| N | 普通攻击 |
| S / S1~S15 | 特殊动作 |

### 音效文件格式

| 属性 | 推荐值 |
|------|--------|
| 格式 | WAV 或 OGG |
| 采样率 | 44100 Hz |
| 位深度 | 16-bit |
| 声道 | 单声道或立体声 |

---

## 六、特效系统底层原理

### 游戏特效架构

Library of Ruina 的战斗特效基于 Unity 的 MonoBehaviour 和 Animator 组件。所有骰子攻击特效都继承自 `Battle.DiceAttackEffect.DiceAttackEffect` 基类。

### DiceAttackEffect 基类核心结构

```csharp
// 游戏源码: Assembly-CSharp/Battle/DiceAttackEffect/DiceAttackEffect.cs
namespace Battle.DiceAttackEffect
{
    [RequireComponent(typeof(SpriteRenderer), typeof(Animator))]
    public class DiceAttackEffect : MonoBehaviour
    {
        protected SpriteRenderer spr;           // 精灵渲染器
        protected Animator animator;            // 动画控制器
        protected float _destroyTime;           // 特效持续时间
        protected BattleUnitModel _self;        // 使用者
        protected Transform _selfTransform;     // 使用者位置
        protected Transform _targetTransform;   // 目标位置

        [SerializeField] protected Vector2 offset;
        [SerializeField] protected Vector3 additionalScale;

        // 初始化 - 根据名称后缀自动定位到对应锚点
        public virtual void Initialize(BattleUnitView self, BattleUnitView target, float destroyTime)
        {
            // 名称包含 "H" -> Hit锚点
            // 名称包含 "J" -> Slash锚点
            // 名称包含 "Z" -> Penetrate锚点
            // 名称包含 "G" -> Guard锚点
        }

        protected virtual void Update()
        {
            _elapsed += Time.deltaTime;
            if (_elapsed >= _destroyTime)
                Object.Destroy(gameObject);
        }
    }
}
```

### 特效加载流程

```
1. XML配置 EffectRes="MyEffect_J"
       ↓
2. DiceEffectManager.CreateBehaviourEffect() 被调用
       ↓
3. BaseMod拦截检查 CustomEffects 字典
       ↓
4a. 找到自定义类 → 创建 GameObject 并添加组件
4b. 未找到 → 从原版资源加载 Prefab
       ↓
5. 调用 Initialize() 设置位置和参数
       ↓
6. 特效播放，到时间后自动销毁
```

### 特效名称与锚点的对应关系

特效会根据名称后缀自动附加到角色的对应攻击锚点：

| 名称后缀 | 锚点类型 |
|----------|----------|
| `_H` | 打击锚点 |
| `_J` | 斩击锚点 |
| `_Z` | 穿刺锚点 |
| `_G` | 防御锚点 |
| `_E` | 回避锚点 |
| `_F` | 远程攻击锚点 |

---

## 七、自定义特效类（C#方式）

### BaseMod 自动注册机制

BaseMod 会自动扫描 DLL 中所有继承自 `DiceAttackEffect` 且类名以 `DiceAttackEffect_` 开头的类：

```csharp
// BaseMod 自动注册逻辑
if (type.IsSubclassOf(typeof(DiceAttackEffect)) && name.StartsWith("DiceAttackEffect_"))
{
    CustomEffects[name.Substring("DiceAttackEffect_".Length).Trim()] = type;
}
```

**命名规则**：
- 类名：`DiceAttackEffect_MyEffect_J`
- XML引用：`EffectRes="MyEffect_J"`

### 创建自定义特效类示例

```csharp
using Battle.DiceAttackEffect;
using UnityEngine;

// 类名必须以 DiceAttackEffect_ 开头
// 后缀 _J 表示斩击特效
public class DiceAttackEffect_MyMod_FlameSlash_J : DiceAttackEffect
{
    private float _intensity = 1f;

    public override void Initialize(BattleUnitView self, BattleUnitView target, float destroyTime)
    {
        base.Initialize(self, target, destroyTime);
        // 自定义初始化逻辑
        CreateFlameEffect();
    }

    private void CreateFlameEffect()
    {
        // 动态创建粒子系统
        GameObject particleObj = new GameObject("FlameParticles");
        particleObj.transform.SetParent(transform);
        particleObj.transform.localPosition = Vector3.zero;

        var ps = particleObj.AddComponent<ParticleSystem>();
        var main = ps.main;
        main.startColor = new Color(1f, 0.5f, 0f);
        main.startSize = 0.5f;
        main.startLifetime = 0.3f;
    }

    protected override void Update()
    {
        base.Update();
        _intensity = Mathf.Lerp(_intensity, 0f, Time.deltaTime * 2f);
    }
}
```

### 在XML中使用

```xml
<Behaviour Min="4" Dice="8" Type="Atk" Detail="Slash" Motion="J"
           EffectRes="MyMod_FlameSlash_J" Script="" Desc="" />
```

---

## 八、使用原版特效

### 常用原版特效列表

| 特效名称 | 说明 |
|----------|------|
| `Basic_H` / `Basic_J` / `Basic_Z` | 基础特效 |
| `ch1_H` / `ch1_J` / `ch1_Z` | 第一章风格 |
| `ch2_H` / `ch2_J` / `ch2_Z` | 第二章风格 |
| `Street_H` / `Street_J` / `Street_Z` | 街头风格 |
| `Hook_H` / `Hook_J` / `Hook_Z` | 钩子事务所风格 |
| `Zwei_H` / `Zwei_J` / `Zwei_Z` | 茨威风格 |
| `Yun_H` / `Yun_J` / `Yun_Z` | 云风格 |
| `Molar_H` / `Molar_J` / `Molar_Z` | 臼齿事务所风格 |
| `Stray_H` / `Stray_J` / `Stray_Z` | 流浪者风格 |
| `Pierr_H` / `Pierr_J` / `Pierr_Z` | 皮埃尔风格 |

### 在XML中引用

```xml
<!-- 使用茨威斩击特效 -->
<Behaviour Min="4" Dice="8" Type="Atk" Detail="Slash" Motion="J"
           EffectRes="Zwei_J" Script="" Desc="" />

<!-- 不指定特效（使用默认） -->
<Behaviour Min="4" Dice="8" Type="Atk" Detail="Slash" Motion="J"
           EffectRes="" Script="" Desc="" />
```

---

## 九、AssetBundle特效制作

### 所需工具

| 工具 | 版本/说明 |
|------|-----------|
| Unity | **2019.3.15f1**（必须与游戏版本一致，从globalgamemanagers确认） |
| AssetStudio | 用于提取游戏原版资源作为参考 |
| 图像编辑软件 | Photoshop / GIMP / Aseprite |

### 特效Prefab结构

```
MyEffect_J (GameObject)
├── SpriteRenderer (组件) - 必需
├── Animator (组件) - 必需
└── [自定义脚本] (可选)
```

### 创建特效动画

1. **准备精灵序列帧**
   - 格式：PNG，带透明通道
   - 建议尺寸：256x256 或 512x512
   - 帧数：通常 8-16 帧

2. **在Unity中创建动画**
   - 将精灵序列拖入场景
   - 创建 Animation Clip
   - 设置帧率（通常 24-30 FPS）

3. **设置Animator Controller**
   - 创建 Animator Controller
   - 添加动画状态，设为自动播放

### 导出AssetBundle

```csharp
// Editor/BuildAssetBundles.cs
using UnityEditor;
using System.IO;

public class BuildAssetBundles
{
    [MenuItem("Assets/Build AssetBundles")]
    static void BuildAllAssetBundles()
    {
        string outputPath = "Assets/AssetBundles";
        if (!Directory.Exists(outputPath))
            Directory.CreateDirectory(outputPath);

        BuildPipeline.BuildAssetBundles(
            outputPath,
            BuildAssetBundleOptions.None,
            BuildTarget.StandaloneWindows64
        );
    }
}
```

### 放置位置

```
SteriaModFolder/
└── Assemblies/
    └── AB/
        ├── mymod_effects           # AssetBundle文件
        └── mymod_effects.manifest  # 清单文件
```

---

## 十、纯代码特效（无需Unity）

如果不想使用Unity，可以完全用代码创建特效。

### 使用LineRenderer创建激光特效

```csharp
public class DiceAttackEffect_MyMod_Laser_J : DiceAttackEffect
{
    private LineRenderer _line;
    private float _progress = 0f;

    public override void Initialize(BattleUnitView self, BattleUnitView target, float destroyTime)
    {
        base.Initialize(self, target, destroyTime);

        _line = gameObject.AddComponent<LineRenderer>();
        _line.material = new Material(Shader.Find("Sprites/Default"));
        _line.startColor = Color.cyan;
        _line.endColor = Color.white;
        _line.startWidth = 0.3f;
        _line.endWidth = 0.1f;
        _line.positionCount = 2;
        _line.SetPosition(0, _selfTransform.position);
        _line.SetPosition(1, _selfTransform.position);
    }

    protected override void Update()
    {
        base.Update();
        _progress += Time.deltaTime / _destroyTime;

        if (_line != null && _targetTransform != null)
        {
            Vector3 targetPos = Vector3.Lerp(
                _selfTransform.position,
                _targetTransform.position,
                _progress);
            _line.SetPosition(1, targetPos);

            // 渐隐效果
            Color c = _line.startColor;
            c.a = 1f - _progress;
            _line.startColor = c;
            _line.endColor = c;
        }
    }
}
```

### 使用SpriteRenderer创建闪光特效

```csharp
public class DiceAttackEffect_MyMod_Flash_H : DiceAttackEffect
{
    protected override void Awake()
    {
        base.Awake();

        if (spr != null)
        {
            // 创建圆形渐变精灵
            Texture2D tex = new Texture2D(64, 64);
            for (int x = 0; x < 64; x++)
            {
                for (int y = 0; y < 64; y++)
                {
                    float dist = Vector2.Distance(new Vector2(x, y), new Vector2(32, 32));
                    float alpha = Mathf.Clamp01(1f - dist / 32f);
                    tex.SetPixel(x, y, new Color(1, 1, 1, alpha));
                }
            }
            tex.Apply();
            spr.sprite = Sprite.Create(tex, new Rect(0, 0, 64, 64), new Vector2(0.5f, 0.5f));
            spr.color = Color.yellow;
        }
    }

    protected override void Update()
    {
        base.Update();

        // 闪烁和缩放动画
        float alpha = Mathf.PingPong(Time.time * 10f, 1f);
        if (spr != null)
            spr.color = new Color(1, 1, 0, alpha);

        float scale = 1f + Mathf.Sin(Time.time * 20f) * 0.2f;
        transform.localScale = Vector3.one * scale * 2f;
    }
}
```

---

## 十一、程序化特效（闪光/离子/激光）

本节介绍游戏中非贴图的程序化特效实现方式，如原版和寒昼mod中的闪光离子型攻击特效。

### 核心技术概述

游戏中的程序化特效主要通过以下几种技术实现：

| 技术 | 适用场景 | 核心组件 |
|------|----------|----------|
| LineRenderer | 激光、光束、链条 | `LineRenderer` + 贝塞尔曲线 |
| Shader闪光 | 角色闪白、发光 | `MaterialPropertyBlock` |
| TrailRenderer | 拖尾、轨迹 | `LineRenderer` + 物理模拟 |
| 2DxFX着色器 | 闪电、扭曲 | 自定义Shader |

### 1. LineRenderer 激光特效

游戏中的激光效果（如R社鲁道夫）使用 `LineRenderer` + 贝塞尔曲线实现。

**源码参考**: `Assembly-CSharp/RCorp_RudolphLaserRenderer.cs`

```csharp
// 激光渲染器核心实现
[RequireComponent(typeof(LineRenderer))]
public class DiceAttackEffect_MyMod_BezierLaser_Z : DiceAttackEffect
{
    private LineRenderer _lineRenderer;
    private List<Vector3> _controlPoints = new List<Vector3>();
    private List<Vector3> _curvePositions = new List<Vector3>();
    private int _curPosIdx = 1;
    private float _elapsedMoving = 0f;
    private float _laserSpeed = 5f;

    public override void Initialize(BattleUnitView self, BattleUnitView target, float destroyTime)
    {
        base.Initialize(self, target, destroyTime);

        // 创建 LineRenderer
        _lineRenderer = gameObject.AddComponent<LineRenderer>();
        _lineRenderer.material = new Material(Shader.Find("Sprites/Default"));
        _lineRenderer.startWidth = 0.2f;
        _lineRenderer.endWidth = 0.1f;
        _lineRenderer.startColor = new Color(0.5f, 0.8f, 1f, 1f);  // 淡蓝色
        _lineRenderer.endColor = new Color(1f, 1f, 1f, 0.5f);

        // 初始化贝塞尔曲线控制点
        InitBezierCurve();
    }

    private void InitBezierCurve()
    {
        Vector3 start = _selfTransform.position;
        Vector3 end = _targetTransform.position;
        Vector3 mid = (start + end) / 2f + Vector3.up * 2f;  // 中间点向上偏移

        // 生成曲线上的点
        int segments = 20;
        _curvePositions.Clear();
        for (int i = 0; i <= segments; i++)
        {
            float t = (float)i / segments;
            Vector3 pos = CalculateBezierPoint(t, start, mid, end);
            _curvePositions.Add(pos);
        }

        _lineRenderer.positionCount = 2;
        _lineRenderer.SetPosition(0, start);
        _lineRenderer.SetPosition(1, start);
    }

    // 二次贝塞尔曲线
    private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2)
    {
        float u = 1f - t;
        return u * u * p0 + 2f * u * t * p1 + t * t * p2;
    }

    protected override void Update()
    {
        base.Update();

        // 逐步延伸激光
        if (_curPosIdx < _curvePositions.Count)
        {
            _elapsedMoving += Time.deltaTime * _laserSpeed;
            if (_elapsedMoving >= 1f)
            {
                _elapsedMoving = 0f;
                _curPosIdx++;
                _lineRenderer.positionCount = _curPosIdx + 1;
            }

            if (_curPosIdx < _curvePositions.Count)
            {
                Vector3 prevPos = _curvePositions[_curPosIdx - 1];
                Vector3 nextPos = _curvePositions[_curPosIdx];
                Vector3 currentPos = Vector3.Lerp(prevPos, nextPos, _elapsedMoving);
                _lineRenderer.SetPosition(_curPosIdx, currentPos);
            }
        }
    }
}
```

### 2. Shader闪光效果

游戏中角色受击闪白效果通过 `MaterialPropertyBlock` 动态修改Shader属性实现。

**源码参考**: `Assembly-CSharp/HurtFlashEffect.cs`

```csharp
// 闪光效果核心实现
public class DiceAttackEffect_MyMod_Flash_H : DiceAttackEffect
{
    private MaterialPropertyBlock _mpb;
    private MeshRenderer _meshRenderer;
    private int _fillPhaseId;
    private int _fillColorId;
    private float _flashProgress = 0f;

    public override void Initialize(BattleUnitView self, BattleUnitView target, float destroyTime)
    {
        base.Initialize(self, target, destroyTime);

        _mpb = new MaterialPropertyBlock();
        _fillPhaseId = Shader.PropertyToID("_FillPhase");
        _fillColorId = Shader.PropertyToID("_FillColor");

        // 获取目标的渲染器
        _meshRenderer = target.GetComponentInChildren<MeshRenderer>();
        if (_meshRenderer != null)
        {
            _meshRenderer.GetPropertyBlock(_mpb);
            StartCoroutine(FlashRoutine());
        }
    }

    private IEnumerator FlashRoutine()
    {
        int flashCount = 3;
        float interval = 0.016f;  // 约60fps
        Color flashColor = Color.white;
        WaitForSeconds wait = new WaitForSeconds(interval);

        for (int i = 0; i < flashCount; i++)
        {
            // 闪光开
            _mpb.SetColor(_fillColorId, flashColor);
            _mpb.SetFloat(_fillPhaseId, 1f);
            _meshRenderer.SetPropertyBlock(_mpb);
            yield return wait;

            // 闪光关
            _mpb.SetFloat(_fillPhaseId, 0f);
            _meshRenderer.SetPropertyBlock(_mpb);
            yield return wait;
        }
    }
}
```

**关键Shader属性**：
| 属性名 | 类型 | 说明 |
|--------|------|------|
| `_FillPhase` | float | 闪光强度 (0-1) |
| `_FillColor` | Color | 闪光颜色 |

### 3. 带物理的拖尾效果

游戏中的拖尾效果支持重力、阻力、湍流等物理模拟，产生类似闪电的抖动效果。

**源码参考**: `Assembly-CSharp/RFX4_TrailRenderer.cs`

```csharp
// 带湍流的拖尾特效（产生闪电般的抖动）
public class DiceAttackEffect_MyMod_LightningTrail_J : DiceAttackEffect
{
    private LineRenderer _lineRenderer;
    private List<Vector3> _positions = new List<Vector3>();
    private List<Vector3> _velocities = new List<Vector3>();

    // 物理参数
    private float _gravity = 0.01f;
    private float _drag = 0.01f;
    private float _turbulenceStrength = 0.5f;  // 湍流强度（越大越像闪电）
    private float _amplitude = 2f;
    private float _frequency = 1f;

    public override void Initialize(BattleUnitView self, BattleUnitView target, float destroyTime)
    {
        base.Initialize(self, target, destroyTime);

        _lineRenderer = gameObject.AddComponent<LineRenderer>();
        _lineRenderer.material = new Material(Shader.Find("Sprites/Default"));
        _lineRenderer.startWidth = 0.15f;
        _lineRenderer.endWidth = 0.05f;
        _lineRenderer.startColor = new Color(0.8f, 0.9f, 1f);
        _lineRenderer.endColor = new Color(0.5f, 0.7f, 1f, 0.3f);

        // 初始化轨迹点
        _positions.Add(_selfTransform.position);
        _velocities.Add(Vector3.zero);
    }

    protected override void Update()
    {
        base.Update();
        UpdateTrail();
        ApplyTurbulence();
        _lineRenderer.positionCount = _positions.Count;
        _lineRenderer.SetPositions(_positions.ToArray());
    }

    private void UpdateTrail()
    {
        Vector3 currentPos = Vector3.Lerp(
            _selfTransform.position,
            _targetTransform.position,
            _elapsed / _destroyTime);

        if (_positions.Count == 0 ||
            Vector3.Distance(currentPos, _positions[_positions.Count - 1]) > 0.1f)
        {
            _positions.Add(currentPos);
            _velocities.Add(Vector3.zero);
        }
    }

    // 使用 Perlin Noise 产生湍流抖动
    private void ApplyTurbulence()
    {
        for (int i = 0; i < _positions.Count; i++)
        {
            Vector3 pos = _positions[i] / _frequency;
            float time = Time.time * 0.5f;

            Vector3 turbulence = Vector3.zero;
            turbulence.x = (Mathf.PerlinNoise(pos.z + time, pos.y) * 2f - 1f)
                           * _amplitude * Time.deltaTime * _turbulenceStrength;
            turbulence.y = (Mathf.PerlinNoise(pos.x + time, pos.z) * 2f - 1f)
                           * _amplitude * Time.deltaTime * _turbulenceStrength;

            _velocities[i] += turbulence;
            _velocities[i] *= (1f - _drag * Time.deltaTime);  // 阻力
            _positions[i] += _velocities[i] * Time.deltaTime;
        }
    }
}
```

### 4. 2DxFX 闪电着色器

游戏内置了 2DxFX 插件的闪电效果，通过着色器实现程序化闪电。

**源码参考**: `Assembly-CSharp/_2dxFX_LightningBolt.cs`

```csharp
// 使用方式：将组件添加到带有 SpriteRenderer 的对象上
// 着色器名称: "2DxFX/Standard/LightningBolt"

// 关键参数
material.SetFloat("_Value1", 64f);   // 分段数 (16-256)，越大越细腻
material.SetFloat("_Value2", 1f);    // 强度 (0-2)
material.SetFloat("_Value3", 1f);    // 宽度 (0-1)
material.SetFloat("_Alpha", 1f);     // 透明度
material.SetTexture("_MainTex2", noiseTexture);  // 噪声纹理
```

### 5. Shader颜色渐变动画

通过 `RFX4_ShaderColorGradient` 实现颜色随时间渐变。

**源码参考**: `Assembly-CSharp/RFX4_ShaderColorGradient.cs`

```csharp
// 颜色渐变控制器
public class ColorGradientEffect : MonoBehaviour
{
    public Gradient colorGradient;      // Unity Gradient
    public float duration = 1f;
    private Material _mat;
    private float _startTime;

    void Start()
    {
        _mat = GetComponent<Renderer>().material;
        _startTime = Time.time;
    }

    void Update()
    {
        float t = (Time.time - _startTime) / duration;
        Color color = colorGradient.Evaluate(t);
        _mat.SetColor("_Color", color);
    }
}
```

### 6. 使用游戏内置特效管理器

通过 `DiceEffectManager` 可以直接调用游戏内置的各种特效。

**源码参考**: `Assembly-CSharp/DiceEffectManager.cs`

```csharp
// 在被动或卡牌能力中调用
public class PassiveAbility_MyMod_FlashOnHit : PassiveAbilityBase
{
    public override void OnSucceedAttack(BattleDiceBehavior behavior)
    {
        // 创建攻击特效
        DiceEffectManager.Instance.CreateBehaviourEffect(
            "Philip_Laser",      // 特效资源名
            1.0f,                // 缩放因子
            _owner.view,         // 使用者
            behavior.card.target.view,  // 目标
            0.5f                 // 持续时间
        );

        // 创建火花特效
        Vector3 hitPos = behavior.card.target.view.WorldPosition;
        DiceEffectManager.Instance.CreateSparkByAtkVsAtk(hitPos);
    }
}
```

### 7. 相关源码文件参考

| 文件 | 说明 |
|------|------|
| `DiceEffectManager.cs` | 特效管理器单例 |
| `DiceAttackEffect.cs` | 攻击特效基类 |
| `RCorp_RudolphLaserRenderer.cs` | 贝塞尔曲线激光 |
| `RFX4_TrailRenderer.cs` | 带物理的拖尾 |
| `HurtFlashEffect.cs` | Shader闪光效果 |
| `RFX4_ShaderColorGradient.cs` | 颜色渐变动画 |
| `_2dxFX_LightningBolt.cs` | 闪电着色器 |
| `LinePatternRenderer.cs` | 简单线条渲染 |
| `LaserController.cs` | 粒子激光控制 |

---

## 十二、资源总结

### 角色皮肤资源

| 资源类型 | 放置位置 | CharacterSkinType |
|----------|----------|-------------------|
| AssetBundle皮肤 | `Resource/AssetBundle/[皮肤名]` | `Lor` |
| 散图皮肤 | `Resource/CharacterSkin/[皮肤名]/` | `Custom` |
| 散图皮肤配置 | `Resource/CharacterSkin/[皮肤名]/ModInfo.Xml` | - |
| 散图皮肤图片 | `Resource/CharacterSkin/[皮肤名]/ClothCustom/` | - |
| 动作音效 | `Resource/MotionSound/` | - |

### 动作类型完整列表

| 动作名 | 说明 | 必须 |
|--------|------|------|
| Default | 默认站姿 | 是 |
| Guard | 防御 | 推荐 |
| Evade | 回避 | 推荐 |
| Damaged | 受伤 | 推荐 |
| Slash | 斩击 | 推荐 |
| Slash2 | 斩击2 | 否 |
| Penetrate | 穿刺 | 推荐 |
| Penetrate2 | 穿刺2 | 否 |
| Hit | 打击 | 推荐 |
| Hit2 | 打击2 | 否 |
| Move | 移动 | 否 |
| Fire | 远程攻击 | 远程角色需要 |
| Aim | 瞄准 | 远程角色需要 |
| Special | 特殊动作 | 否 |
| S1~S15 | 额外特殊动作 | 否 |

### 特效资源

| 资源类型 | 放置位置 |
|----------|----------|
| AssetBundle特效 | `Assemblies/AB/[包名]` |
| C#特效类 | `Assemblies/[Mod].dll` 中 |

### 制作工具推荐

| 用途 | 工具 |
|------|------|
| 角色立绘 | Photoshop / Clip Studio Paint / Aseprite |
| 特效动画 | After Effects / Spine / Unity |
| 音效编辑 | Audacity / Adobe Audition |
| AssetBundle打包 | Unity 2019.3.15f1 |
| 资源提取 | AssetStudio |

---

## 十三、高质量特效制作方法（案例分析）

本节通过逆向分析寒昼事务所等高质量mod的特效资源，总结出专业级特效的制作方法。

### 案例：寒昼事务所「冰砸」特效

以下是从寒昼事务所mod中提取的「冰砸」特效资源分析。

#### 资源清单

| 类型 | 文件 | 尺寸/规格 | 用途 |
|------|------|-----------|------|
| Mesh | 刀光002.obj | 330顶点, 512面 | 弯曲的刀光3D形状 |
| Mesh | Plane001.obj | 平面 | 承载2D贴图 |
| Texture2D | daoguang.png | 512x512 | 刀光主体纹理 |
| Texture2D | feng01.png | 512x512 | 风/气流效果 |
| Texture2D | lan_breathSmoke.png | 512x512 | 冷气烟雾 |
| Texture2D | Noise_004.png | 256x256 | 扰动/溶解噪声 |
| Texture2D | Noise_005.png | 512x512 | 扰动/溶解噪声 |
| Texture2D | adv_aura_Dust.png | 256x256 | 碎冰尘埃颗粒 |
| Shader | 新时代/色散 | - | RGB色散效果 |
| Timeline | 冰砸Timeline | 1.18秒 | 时序控制 |

#### 贴图特征分析

通过Python分析各贴图的视觉特征：

**daoguang.png（刀光主体）**
```
形状：横向渐变条
特点：中间亮，边缘暗
用途：定义刀光的纹理细节
ASCII预览：
    ..:--------------======-----::..
    .:-=*#%@@@@@@@@@@@@@@@%%##+=-:.
       .:-=+*********++=:...
```

**feng01.png（风效）**
```
形状：流线型渐变
特点：上半部分亮，下半部分渐暗
用途：气流/风的视觉效果
ASCII预览：
       ..::--====+++++===-::.
      .-=++******+++++****+++=-.
         :=++++++++++++++++++-:
```

**lan_breathSmoke.png（烟雾）**
```
形状：圆形云团
特点：中心亮，边缘柔和渐变
用途：冷气/烟雾效果
```

**Noise_004/005.png（噪声）**
```
形状：随机噪点分布
特点：Perlin噪声图案
用途：边缘扰动、溶解效果
```

#### Mesh结构分析

**刀光002.obj** - 不是简单的平面，而是精心建模的3D形状：

```
规格：330顶点，512三角面

形状示意（侧视图）：
        ╱────────────╲
       ╱              ╲
      ╱                ╲
     ●                  ●
   尖端起点            尖端终点

特点：
- 弯曲的"刀片"形状
- 两端收尖
- UV展开用于贴图映射
- 可能包含顶点色控制透明度渐变
```

#### Shader分析

**新时代/色散** - 用于产生"冰冷/科技"视觉感：

```hlsl
Properties {
    _Vector0 ("GB偏移", Vector) = (0,0,0,0)  // RGB通道偏移量
    [Toggle] _Keyword0 ("是否开启粒子控制缩放", Float) = 0
}

原理：
1. GrabPass 抓取当前屏幕内容
2. 对R/G/B三个通道分别采样不同位置
3. 产生彩虹色边缘分离效果

视觉效果：
  原图: [RGB混合]
         ↓
  色散: [R偏左][G居中][B偏右]
         ↓
  结果: 边缘出现彩色光晕
```

**新时代/新通用Shader** - 高度可配置的特效Shader框架：

```hlsl
// 核心功能模块
Properties {
    // 渲染控制
    [Enum(UnityEngine.Rendering.CullMode)] _Float14 ("CullMode", Float) = 2
    [Enum(UnityEngine.Rendering.BlendMode)] _Float6 ("S", Float) = 5
    [Enum(UnityEngine.Rendering.BlendMode)] _Float13 ("D", Float) = 10

    // UV流动控制
    [KeywordEnum(UV2U,Time)] _Keyword2 ("主UV流动方式", Float) = 1
    [KeywordEnum(UV2V,Time)] _Keyword3 ("蒙版1流动方式", Float) = 1

    // 透明度/溶解控制
    [KeywordEnum(VertexColorA,UV2W)] _Keyword6 ("透明度控制", Float) = 0
    [KeywordEnum(MySelfValue,VertexColorA,UV2Z)] _Keyword5 ("溶解度控制", Float) = 0

    // 贴图槽位
    _TextureSample0 ("主材质", 2D) = "white" {}
    _TextureSample4 ("扭曲贴图", 2D) = "white" {}
    _TextureSample1 ("Mask蒙版", 2D) = "white" {}
}

技术亮点：
- 多Keyword变体：编译出几十个Shader变体适应不同需求
- 顶点色多通道利用：R/G/B/A各有用途
- UV2多通道：UV2.U/V/W/Z四个分量分别控制不同功能
- 高度可复用：一个Shader适配多种特效
```

#### 组装方式

```
冰砸.prefab 层级结构：

冰砸 (Root GameObject)
├── 刀光主体 (MeshRenderer + 刀光002.obj)
│   └── Material: 新通用Shader + daoguang.png
├── 烟雾层 (MeshRenderer + Plane001.obj)
│   └── Material: 新通用Shader + lan_breathSmoke.png
├── 风效层 (MeshRenderer + Plane001.obj)
│   └── Material: 新通用Shader + feng01.png
├── 尘埃层 (Plane 或 ParticleSystem)
│   └── Material: adv_aura_Dust.png
└── PlayableDirector
    └── 冰砸Timeline.playable
```

#### Timeline时序编排

```
时间轴 (0.0s → 1.18s)
═══════════════════════════════════════════════════

Track 1 (刀光002): [████████████████████████████████████]
                   0.0s                           1.18s

Track 2-10 (烟雾/风效/尘埃等):
    各层有不同的出现时机、持续时间、淡入淡出
```

#### 制作流程总结

```
完整制作流程：

[1. 概念设计]
    ↓ 确定特效风格、元素组成
[2. 贴图绘制] ←── Photoshop / Substance
    ↓ 主体纹理 + 辅助效果 + Noise
[3. 模型制作] ←── Blender / Maya
    ↓ 刀光Mesh（弯曲形状 + 顶点色）
[4. Shader准备] ←── 复用通用Shader 或 手写
    ↓ 配置材质参数
[5. Unity组装] ←── 创建Prefab层级结构
    ↓ 多层叠加：刀光 + 风 + 烟雾 + 尘埃
[6. Timeline编排] ←── 精确到帧的时序控制
    ↓ 淡入淡出、缩放动画
[7. 导出AssetBundle]
    ↓ Unity 2019.3.15f1
[8. 集成到Mod]
```

#### 核心公式

```
专业级特效 = Mesh(3D形状)
           + Texture2D(贴图纹理)
           + Shader(渲染效果)
           + Timeline(时序控制)
           + 多层叠加(丰富视觉)
```

---

## 十四、致敬：社区特效开发者

Library of Ruina 的高质量mod特效制作门槛极高，需要同时掌握 Unity、Shader编程、3D建模和美术设计。全球范围内，能够制作出专业级特效的开发者屈指可数。

以下几位开发者为社区贡献了大量高质量的特效资源，撑起了绝大多数顶级mod的视觉表现：

### 中国社区

| 开发者 | 贡献 |
|--------|------|
| **_帽子_（華鳥風月）** | 顶级特效开发者 |
| **阿末** | 顶级特效开发者 |
| **林深长音** | 顶级特效开发者 |

这三位开发者的作品涵盖了国内80%以上的高质量mod特效。

### 海外社区

| 开发者 | 贡献 |
|--------|------|
| **담담이** | 海外顶级特效开发者，高下载量榜单常客 |

### 技术门槛说明

制作专业级mod特效需要以下技能的综合运用：

```
特效开发技能树：

Unity引擎 ─────────┐
                   │
Shader编程 ────────┼──→ 专业级特效
(HLSL/ShaderLab)   │
                   │
3D建模 ────────────┤
(Blender/Maya)     │
                   │
美术设计 ──────────┤
(贴图绘制/配色)    │
                   │
Timeline编排 ──────┘
```

这些技能的学习曲线陡峭，通常需要1-2年的专注学习才能达到可用水平。

### 特效制作的核心公式

通过分析寒昼事务所等高质量mod的特效资源，总结出以下制作公式：

```
专业特效 = Mesh(3D形状)
         + Texture2D(贴图纹理)
         + Shader(渲染效果)
         + Timeline(时序控制)
```

**感谢以上开发者为 Library of Ruina mod社区做出的卓越贡献！**
